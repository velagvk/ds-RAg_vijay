"""

# Standard response schema for regular elements
response_schema = {
    "type": "array",
    "items": {
        "type": "object",
        "properties": {
            "type": {
                "type": "string",
            },
            "content": {
                "type": "string",
            },
        },
        "required": ["type", "content"],
    },
}

# Specialized response schema for structured table extraction
table_response_schema = {
    "type": "array",
    "items": {
        "type": "object",
        "properties": {
            "type": {
                "type": "string",
            },
            "content": {
                "oneOf": [
                    {
                        "type": "string"
                    },
                    {
                        "type": "object",
                        "properties": {
                            "title": {
                                "type": "string",
                                "description": "Title or caption of the table if present"
                            },
                            "headers": {
                                "type": "array",
                                "items": {
                                    "type": "string"
                                },
                                "description": "Column headers of the table"
                            },
                            "data": {
                                "type": "array",
                                "items": {
                                    "type": "array",
                                    "items": {
                                        "type": "string"
                                    }
                                },
                                "description": "Table data as array of rows, where each row is an array of cell values"
                            },
                            "notes": {
                                "type": "string",
                                "description": "Any footnotes or notes associated with the table"
                            }
                        },
                        "required": ["headers", "data"]
                    }
                ]
            },
        },
        "required": ["type", "content"],
    },
}

# Specialized system message for structured table extraction
TABLE_SYSTEM_MESSAGE = """
You are a PDF -> structured data parser. Your task is to analyze the provided PDF page (provided as an image) and return a structured JSON response containing all of the elements on the page. Each element must be represented using Markdown formatting.

There are two categories of elements you need to identify: text elements and visual elements. Text elements are those that can be accurately represented using plain text. Visual elements are those that need to be represented as images to fully capture their content. For text elements, you must provide the exact text content. For visual elements, you must provide a detailed description of the content.

There are {num_visual_elements} types of visual elements: {visual_elements_as_str}.
There are {num_non_visual_elements} types of text elements: {non_visual_elements_as_str}.

Every element on the page should be classified as one of these types. There should be no overlap between elements. You should use the smallest number of elements possible while still accurately representing and categorizing the content on the page. For example, if the page contains a couple paragraphs of text, followed by a large figure, followed by a few more paragraphs of text, you should use three elements: NarrativeText, Figure, and NarrativeText. With that said, you should never combine two different types of elements into a single element.

Here are detailed descriptions of the element types you can use:
{element_description_block}

**SPECIAL HANDLING FOR TABLES:**
For Table elements, you must provide structured data in the "content" field as a JSON object with the following structure:
- "title": The title or caption of the table (if present)
- "headers": An array of column header names
- "data": An array of rows, where each row is an array of cell values corresponding to the headers
- "notes": Any footnotes or notes associated with the table (if present)

Example table structure:
{{
  "title": "Financial Performance 2023",
  "headers": ["Quarter", "Revenue", "Profit"],
  "data": [
    ["Q1", "$100M", "$20M"],
    ["Q2", "$120M", "$25M"],
    ["Q3", "$110M", "$22M"],
    ["Q4", "$130M", "$28M"]
  ],
  "notes": "All figures in USD"
}}

For non-Table visual elements ({visual_elements_as_str}), you must provide a detailed description of the element in the "content" field. Do not just transcribe the actual text contained in the element. For textual elements ({non_visual_elements_as_str}), you must provide the exact text content of the element.

If there is any sensitive information in the document, YOU MUST IGNORE IT. This could be a SSN, bank information, etc. Names and DOBs are not sensitive information.

Output format
- Your output should be an ordered (from top to bottom) list of elements on the page, where each element is a dictionary with the following keys:
    - type: str - the type of the element
    - content: str or object - for Table elements, this should be a structured JSON object as described above. For all other elements, this should be a string with the content or description.

Complex and multi-part figures or images should be represented as a single element. For example, if a figure consists of a main chart and a smaller inset chart, these should be described together in a single Figure element. If there are two separate graphs side by side, these should be represented as a single Figure element with a bounding box that encompasses both graphs. DO NOT create separate elements for each part of a complex figure or image.

"""



  has_structured_tables = any(
        element_type.get("extract_structure", False) for element_type in element_types
    )
    
    # Choose appropriate system message and response schema
    if has_structured_tables:
        system_message = TABLE_SYSTEM_MESSAGE.format(
            num_visual_elements=get_num_visual_elements(element_types),
            num_non_visual_elements=get_num_non_visual_elements(element_types),
            visual_elements_as_str=get_visual_elements_as_str(element_types),
            non_visual_elements_as_str=get_non_visual_elements_as_str(element_types),
            element_description_block=get_element_description_block(element_types)
        )
        response_schema_to_use = table_response_schema
    else:
        system_message = SYSTEM_MESSAGE.format(
            num_visual_elements=get_num_visual_elements(element_types),
            num_non_visual_elements=get_num_non_visual_elements(element_types),
            visual_elements_as_str=get_visual_elements_as_str(element_types),
            non_visual_elements_as_str=get_non_visual_elements_as_str(element_types),
            element_description_block=get_element_description_block(element_types)
        )
        response_schema_to_use = response_schema






def _serialize_table_content(content: dict) -> str:
    """
    Serializes a structured table dictionary into a Markdown string.
    """
    markdown_parts = []
    
    # Handle table title
    if "title" in content and content["title"]:
        markdown_parts.append(f"### {content['title']}")

    # Handle table headers and data
    if "headers" in content and content["headers"]:
        headers = content["headers"]
        header_line = "| " + " | ".join(map(str, headers)) + " |"
        separator_line = "| " + " | ".join(["---"] * len(headers)) + " |"
        markdown_parts.append(header_line)
        markdown_parts.append(separator_line)

        if "data" in content and content["data"]:
            for row in content["data"]:
                row_line = "| " + " | ".join(map(str, row)) + " |"
                markdown_parts.append(row_line)
    
    # Handle table notes
    if "notes" in content and content["notes"]:
        # Add a newline for spacing if there was a table body
        if markdown_parts:
            markdown_parts.append("")
        markdown_parts.append(f"Notes: {content['notes']}")

    return "\n".join(markdown_parts)

def elements_to_lines(
    elements: List[Element],
    exclude_elements: List[str],
    visual_elements: List[str],
    max_line_length: int = 200
) -> List[Line]:
    """
    Converts a list of Element objects into a list of Line objects.
    Handles serialization of structured table content.
    """
    document_lines = []
    for element in elements:
        try:
            if element["type"] in exclude_elements:
                continue

            element_content = element["content"]
            is_visual = element["type"] in visual_elements

            # Serialize structured table content to Markdown string
            if isinstance(element_content, dict):
                if element["type"] == "Table":
                    element_content = _serialize_table_content(element_content)
                else:
                    # For other potential dicts, just convert to string representation
                    element_content = str(element_content)
            
            # Non-visual elements are split by newlines and have their lines constrained
            if not is_visual:
                lines = element_content.split("\n")
                for line in lines:
                    if len(line) <= max_line_length:
                        document_lines.append({
                            "content": line,
                            "element_type": element["type"],
                            "page_number": element.get("page_number", None),
                            "is_visual": False,
                        })
                    else:
                        # Split long lines
                        split_lines = split_long_line(line, max_line_length)
                        for split_line in split_lines:
                            document_lines.append({
                                "content": split_line,
                                "element_type": element["type"],
                                "page_number": element.get("page_number", None),
                                "is_visual": False,
                            })
            else:
                # Visual elements are not split
                document_lines.append({
                    "content": element_content,
                    "element_type": element["type"],
                    "page_number": element.get("page_number", None),
                    "is_visual": True,
                })

        except Exception as e:
            logger.error(f"Error in elements_to_lines: {e}")
            logger.error(f"Problematic Element: {element}")
            raise e
    
    return document_lines
